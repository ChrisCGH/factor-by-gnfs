#pragma GCC diagnostic ignored "-Wundefined-var-template"
#include "Ideal.h"
#include "AlgebraicNumber_in_O_pO.h"
#include "pow.h"
#include "lll.h"

Timing* Ideal::timing_ = 0;

Ideal::Ideal() : hnf_basis_(1,1), denominator_(1L), isPrincipal_(false)
{
    //const NumberField& n(AlgebraicNumber::nf());
    AlgebraicNumber::nf();
}

Ideal::Ideal(const VeryLong& p, const VeryLong& q)
      : hnf_basis_(1,1), denominator_(1L), isPrincipal_(false)
{
   //const NumberField& n(AlgebraicNumber::nf());
   AlgebraicNumber::nf();
   long int d = AlgebraicNumber::degree();
   // special case for "infinite" root
   if (p == q)
   {
      std::vector<AlgebraicNumber> j;
      AlgebraicNumber::createSpecialBasis(p, j);
      create(j);
      return;
   }
   // Ideal is generated by p and c_d(alpha - q) where
   // we assume that f(q) = 0 mod p where f is the
   // defining minimal polynomial of Algebraic::numberField_
   // and f(alpha) = 0, i.e. alpha is a (complex) root of f,
   // and c_d is coefficient of X^d in f, d is degree of f
   // We also assume that p doesn't divide c_d

   // We can represent a basis of the ideal by a set of vectors
   // or a matrix, where each column of the matrix is one of the basis
   // vectors.
   // We can then reduce to HNF form to get a canonical basis.
   // If the minimal polynomial has degree d, then each vector has
   // d coefficients, and we need d to span the ideal,
   // giving a d x d matrix:
   //cout << "Ideal::Ideal(" << p << ", " << q << ")" << endl;
   Matrix<Quotient<VeryLong > > qbasis(d, 2 * d);
   Matrix<VeryLong> basis(d, 2 * d);
   const std::vector<AlgebraicNumber>& ib = AlgebraicNumber::integralBasis();

   std::vector<Quotient<VeryLong > > c;
   VeryLong lcm(1L);
   c.resize(d);
   c[0] = Quotient<VeryLong>(p);
   for (int i = 1; i < d; i++) c[i] = Quotient<VeryLong>(0L);
   AlgebraicNumber p_an(c);

   VeryLong c_d = AlgebraicNumber::c_d();
   c[0] = Quotient<VeryLong>(c_d * q * VeryLong(-1L));
   c[1] = Quotient<VeryLong>(c_d);
   AlgebraicNumber q_an(c);
   AlgebraicNumber w;
   int col = 0;
   for (size_t i = 0; i < ib.size(); i++)
   {
      w = p_an * ib[i];
      for (int j = 0; j < d; j++)
      {
         qbasis(j,col) = w.coefficients()[j];
         if (w.coefficients()[j].denominator() != VeryLong(1L))
         {
            lcm = lcm * w.coefficients()[j].denominator() / gcd(lcm, w.coefficients()[j].denominator());
         }
      }
      col++;
      w = q_an * ib[i];
      for (int j = 0; j < d; j++)
      {
         qbasis(j,col) = w.coefficients()[j];
         if (w.coefficients()[j].denominator() != VeryLong(1L))
         {
            lcm = lcm * w.coefficients()[j].denominator() / gcd(lcm, w.coefficients()[j].denominator());
         }
      }
      col++;
   }

   denominator_ = lcm;

   for (int i = 0; i < d; i++)
   {
      for (int j = 0; j < 2 * d; j++)
      {
         basis(i,j) = qbasis(i,j).numerator() * (lcm / qbasis(i,j).denominator());
      }
   }
//   cout << "basis for I(" << p << "," << q << ") = " << endl;
//   cout << basis;

   //hnf_basis_ = HNF(basis);
   hnf_basis_ = HNF1(basis);
//   cout << "HNF basis for I(" << p << "," << q << ") = " << endl;
//   cout << hnf_basis_;
//   cout << "Ideal::Ideal(" << p << ", " << q << ") = " << endl;
//   cout << *this << endl;
//   cout << "Norm = " << norm() << endl;
}

Ideal::Ideal(const VeryLong& p, const AlgebraicNumber& beta)
      : hnf_basis_(1,1), denominator_(1L), isPrincipal_(false)
{
   //const NumberField& n(AlgebraicNumber::nf());
   AlgebraicNumber::nf();
   long int d = AlgebraicNumber::degree();
   Matrix<Quotient<VeryLong > > qbasis(d, 2 * d);
   Matrix<VeryLong> basis(d, 2 * d);
   VeryLong lcm(1L);
   const std::vector<AlgebraicNumber>& ib = AlgebraicNumber::integralBasis();

   std::vector<Quotient<VeryLong > > c;
   c.resize(d);
   c[0] = Quotient<VeryLong>(p);
   for (int i = 1; i < d; i++) c[i] = Quotient<VeryLong>(0L);
   AlgebraicNumber p_an(c);

   AlgebraicNumber w;
   int col = 0;
   for (size_t i = 0; i < ib.size(); i++)
   {
      w = p_an * ib[i];
      for (int j = 0; j < d; j++)
      {
         qbasis(j,col) = w.coefficients()[j];
         if (w.coefficients()[j].denominator() != VeryLong(1L))
         {
            lcm = lcm * w.coefficients()[j].denominator() / gcd(lcm, w.coefficients()[j].denominator());
         }
      }
      col++;
      w = beta * ib[i];
      for (int j = 0; j < d; j++)
      {
         qbasis(j,col) = w.coefficients()[j];
         if (w.coefficients()[j].denominator() != VeryLong(1L))
         {
            lcm = lcm * w.coefficients()[j].denominator() / gcd(lcm, w.coefficients()[j].denominator());
         }
      }
      col++;
   }
   denominator_ = lcm;

   for (int i = 0; i < d; i++)
   {
      for (int j = 0; j < 2 * d; j++)
      {
         basis(i,j) = qbasis(i,j).numerator() * (lcm / qbasis(i,j).denominator());
      }
   }

   //hnf_basis_ = HNF(basis);
   hnf_basis_ = HNF1(basis);
}

Ideal::Ideal(const AlgebraicNumber& a) : hnf_basis_(1,1), denominator_(1L), isPrincipal_(true)
{
   //const NumberField& n(AlgebraicNumber::nf());
   AlgebraicNumber::nf();
   long int d = AlgebraicNumber::degree();
   Matrix<Quotient<VeryLong > > qbasis(d, d);
   Matrix<VeryLong> basis(d, d);
   VeryLong lcm(1L);
   const std::vector<AlgebraicNumber>& ib = AlgebraicNumber::integralBasis();

#ifdef XYX
   for (int i = 2; i < d; i++)
   {
      if (a.coefficients()[i].numerator() != 0L) isPrincipal_ = false;
   }
   if (isPrincipal_)
   {
      a_ = a.coefficients()[0].numerator();
      b_ = a.coefficients()[1].numerator() * (-1L);
   }
#endif

   AlgebraicNumber w;
   int col = 0;
   for (size_t i = 0; i < ib.size(); i++)
   {
      w = a * ib[i];
      for (int j = 0; j < d; j++)
      {
         qbasis(j,col) = w.coefficients()[j];
         if (w.coefficients()[j].denominator() != VeryLong(1L))
         {
            lcm = lcm * w.coefficients()[j].denominator() / gcd(lcm, w.coefficients()[j].denominator());
         }
      }
      col++;
   }
   denominator_ = lcm;

   for (int i = 0; i < d; i++)
   {
      for (int j = 0; j < d; j++)
      {
         basis(i,j) = qbasis(i,j).numerator() * (lcm / qbasis(i,j).denominator());
      }
   }

   //hnf_basis_ = HNF(basis);
   hnf_basis_ = HNF1(basis);
}

void Ideal::create(const std::vector<AlgebraicNumber>& generator)
{
   long int d = AlgebraicNumber::degree();
   Matrix<VeryLong> basis(d, generator.size() * d);
   Matrix<Quotient<VeryLong > > qbasis(d, generator.size() * d);
   const std::vector<AlgebraicNumber>& ib = AlgebraicNumber::integralBasis();
   int col = 0;
   VeryLong lcm(1L);
   for (int i = 0; i < d; i++)
   {
      for (size_t j = 0; j < generator.size(); j++)
      {
         AlgebraicNumber w = ib[i] * generator[j];
         for (int k = 0; k < d; k++)
         {
            // assuming generator are algebraic integers, this is ok
            qbasis(k,col) = w.coefficients()[k];
            if (w.coefficients()[k].denominator() != VeryLong(1L))
            {
               lcm = lcm * w.coefficients()[k].denominator() / gcd(lcm, w.coefficients()[k].denominator());
            }
         }
         col++;
      }
   }
   denominator_ = lcm;

   for (int i = 0; i < d; i++)
   {
      for (size_t j = 0; j < d * generator.size(); j++)
      {
         basis(i,j) = qbasis(i,j).numerator() * (lcm / qbasis(i,j).denominator());
      }
   }

   //hnf_basis_ = HNF(basis);
   hnf_basis_ = HNF1(basis);
}

Ideal::Ideal(const std::vector<AlgebraicNumber>& generator)
      : hnf_basis_(1,1), denominator_(1L), isPrincipal_(false)
{
   //const NumberField& n(AlgebraicNumber::nf());
   AlgebraicNumber::nf();
   create(generator);
}

Ideal::Ideal(const Matrix<VeryLong>& basis) : hnf_basis_(1,1), denominator_(1L), isPrincipal_(false)
{
   //const NumberField& n(AlgebraicNumber::nf());
   AlgebraicNumber::nf();
   //hnf_basis_ = HNF(basis);
   hnf_basis_ = HNF1(basis);
//   cout << "Ideal(basis), basis = " << endl << basis;
//   cout << "HNF basis = " << endl;
//   cout << hnf_basis_;
}

Ideal::Ideal(const Ideal& id) : hnf_basis_(id.hnf_basis_), denominator_(id.denominator_), isPrincipal_(id.isPrincipal_)
{
   //const NumberField& n(AlgebraicNumber::nf());
   AlgebraicNumber::nf();
}

Ideal::Ideal(const Matrix<VeryLong>& hnf, const VeryLong& denom) 
    : hnf_basis_(hnf), denominator_(denom), isPrincipal_(false)
{
   //const NumberField& n(AlgebraicNumber::nf());
   AlgebraicNumber::nf();
}
Ideal& Ideal::operator*=(const VeryLong& v)
{
   VeryLong k = gcd(v, denominator_);
   VeryLong v1 = v / k;
   int degree = hnf_basis_.columns();
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree; j++)
      {
         hnf_basis_(i,j) = hnf_basis_(i,j) * v1;
      }
   }
   //hnf_basis_ = HNF(hnf_basis_);
   hnf_basis_ = HNF1(hnf_basis_);
   denominator_ /= k;
   return *this;
}

Ideal& Ideal::operator/=(const VeryLong& v)
{

   Ideal J(AlgebraicNumber(1L));
   J *= v;
   *this = *this * J.invert();

   return *this;
}

int Ideal::operator==(const Ideal& id) const
{
   if (denominator_ != id.denominator_) return 0;
   if (hnf_basis_ != id.hnf_basis_) return 0;
   return 1;
}

Ideal& Ideal::operator=(const Ideal& id)
{
//   cout << "Ideal::operator=(id) : id = " << endl << id.hnf_basis_;
   if (this != &id)
   {
      hnf_basis_ = id.hnf_basis_;
      denominator_ = id.denominator_;
      isPrincipal_ = id.isPrincipal_;
   }
   return *this;
}

Ideal operator*(const Ideal& I, const Ideal& J)
{
   // To multiply I and J, create d x d^2 matrix
   // of products of columns (as algebraic numbers)
   // and get HNF of this
//   cout << "I * J : " << endl;
//   cout << "basis for I = " << endl << I.hnf_basis_;
//   cout << "basis for J = " << endl << J.hnf_basis_;
   int d = I.hnf_basis_.rows();
   Matrix<VeryLong> basis(d, d*d);
   Matrix<VeryLong> denom(d, d*d);
   VeryLong lcm(1L);

   int k = 0;
   for (int i = 0; i < d; i++)
   {
      for (int j = 0; j < d; j++)
      {
         AlgebraicNumber v = AlgebraicNumber(I.hnf_basis_, 1L, i) * AlgebraicNumber(J.hnf_basis_, 1L, j);
         //std::cerr << "v : (i,j) = (" << i << "," << j << ") : " << v << std::endl;
         for (int l = 0; l < d; l++)
         {
            basis(l,k) = v.coefficient(l).numerator();
            denom(l,k) = v.coefficient(l).denominator();
            lcm = lcm * v.coefficient(l).denominator() / gcd(lcm, v.coefficient(l).denominator());
         }
         k++;
      }
   }

   for (int i = 0; i < d; ++i)
   {
       for (int k = 0; k < d*d; ++k)
       {
           basis(i,k) *= lcm;
           basis(i,k) /= denom(i,k);
       }
   }
   Ideal K;
//   cout << "basis for product = " << endl << basis;
   //K.hnf_basis_ = HNF(basis);
   K.hnf_basis_ = HNF1(basis);
   K.denominator_ = I.denominator_ * J.denominator_ * lcm;
   VeryLong g(K.hnf_basis_(0,0));
   for (int i = 0; i < d; i++)
   {
      for (int j = 0; j < d; j++)
      {
         g = gcd<VeryLong>(g, K.hnf_basis_(i,j));
      }
   }
   VeryLong g1 = gcd<VeryLong>(g, K.denominator_);
   K.denominator_ /= g1;
   for (int i = 0; i < d; i++)
   {
      for (int j = 0; j < d; j++)
      {
         K.hnf_basis_(i,j) /= g1;
      }
   }

//   cout << "HNF basis for product = " << endl << K.hnf_basis_;
   return K;
}

// Algorithm 4.8.21 (Ideal Inversion)
Ideal Ideal::invert() const
{
   if (!isIntegral())
   {
        VeryLong lcm;
        Matrix<VeryLong> AA;
        Ideal::integralPart(*this, lcm, AA);
        Ideal J1(*this);
        J1 *= lcm;
        Ideal J1inv(J1.invert());
        J1inv *= lcm;
        return J1inv;
   }
   int degree = hnf_basis_.rows();
   const NumberField& nf = AlgebraicNumber::nf();
   static std::vector<AlgebraicNumber> delta;
   static Matrix<Quotient<VeryLong> > T;
   static Quotient<VeryLong> qd;

   static bool first_time = true;
   if (first_time)
   {
      first_time = false;
      const std::vector<AlgebraicNumber>& omega = AlgebraicNumber::integralBasis();

      // Step 1. [Compute d(K) del(K)^-1]

      T.set_size(degree, degree);
      for (int i = 0; i < degree; i++)
      {
         for (int j = 0; j < degree; j++)
         {
            AlgebraicNumber t_ij = omega[i] * omega[j];
            T(i,j) = t_ij.trace();
         }
      }

      //cout << "T = " << endl << T;
      qd = determinant(T);
      VeryLong d = qd.numerator();
      //cout << "qd = " << qd << endl;

      Matrix<Quotient<VeryLong> > Tinv(degree, degree);
      ::invert(T, Tinv);
      //cout << "Tinv = " << endl << Tinv;

      delta.resize(degree);

      const VeryLong zero(0L);
      for (int col = 0; col < degree; col++)
      {
         AlgebraicNumber tmp(zero);
         for (int row = 0; row < degree; row++)
         {
            tmp += omega[row] * Tinv(row,col) * qd;
         }
         delta[col] = tmp;
         //cout << "delta[" << col << "] = " << delta[col] << endl;
         //cout << "N(delta[" << col << "]) = " << delta[col].norm() << endl;
      }
      timing_ = new Timing("Ideal.tim", false);
   }

   timing_->start("Invert Step 2a");
   // Step 2. [Compute d(K) I del(K)^-1]
   Matrix<Quotient<VeryLong> > NN(degree, degree * degree);
   int ij = 0;
   for (int i = 0; i < degree; i++)
   {
      AlgebraicNumber gamma_i(hnf_basis_, denominator_, i);
      //cout << "gamma[" << i << "] = " << gamma_i << endl;
      for (int j = 0; j < degree; j++)
      {
         AlgebraicNumber tmp = gamma_i * delta[j];
         //cout << "gamma[" << i << "] * delta[" << j << "] = " << tmp << endl;
         for (int row = 0; row < degree; row++)
         {
            NN(row, ij) = tmp.coefficients()[row];
         }
         ij++;
      }
   }
   timing_->stop();
   timing_->start("Invert Step 2b");
   //cout << "NN = " << endl << NN;
   // NN is in terms of alpha, but we need it in terms of omega

   Matrix<Quotient<VeryLong> > N1 = nf.winv() * NN;
   //cout << "N1 = " << endl << N1;
   Matrix<VeryLong> N2(degree, degree*degree);
   const VeryLong one(1L);
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree * degree; j++)
      {
         N2(i,j) = N1(i,j).numerator();
         if (N1(i,j).denominator() != one)
         {
            std::ostringstream oss;
            oss << "Problem N1(" << i << "," << j << ") is not an integer: " << N1(i,j) << std::endl;
            throw oss.str();
         }
      }
   }
   //std::cout << "N2 = " << std::endl << N2;
   timing_->stop();
   timing_->start("Invert Step 2c");
   //Matrix<VeryLong> N = HNF(N2);
   Matrix<VeryLong> N = HNF1(N2);
   //cout << "N = " << endl << N;
   //cout << "det(N) = " << determinant(N) << endl;

   timing_->stop();
   timing_->start("Invert Step 3");

   // Step 3. [Compute I^-1]
   Matrix<Quotient<VeryLong> > P(degree, degree);
   Matrix<Quotient<VeryLong> > PP(degree, degree);
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree; j++)
      {
         PP(i,j) = N(j,i);
      }
   }

   PP = PP * T;

   ::invert(PP, P);
   //cout << "P = " << endl << P;
   P *= qd;
   //cout << "P = " << endl << P;

   // P gives basis for inverse ideal in terms of omega
   // but we want the basis in terms of alpha
   PP = nf.w() * P;
   //cout << "PP = " << endl << PP;

   VeryLong e(1L);
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree; j++)
      {
         e = e * PP(i,j).denominator() / gcd(e, PP(i,j).denominator());
      }
   }
   //cout << "e = " << e << endl;

   Matrix<VeryLong> WW(degree, degree);
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree; j++)
      {
         Quotient<VeryLong> tmp = PP(i,j) * e;
         WW(i,j) = tmp.numerator();
         if (tmp.denominator() != one)
         {
            //cout << "Problem: tmp = " << tmp << endl;
         }
      }
   }

   //cout << "WW = " << endl << WW;
   //Matrix<VeryLong> W = HNF(WW);
   Matrix<VeryLong> W = HNF1(WW);
   //cout << "W = " << endl << W;
   //cout << "det(W) = " << determinant(W) << endl;

   timing_->stop();
   return Ideal(W, e);
}

Ideal operator/(const Ideal& I, const Ideal& J)
{
   return I * J.invert();
}

Ideal intersection(const Ideal& I, const Ideal& J)
{
   // from Algorithm 2.3.9 (p. 63)
   // (Intersection of Subspaces)
   // step 1. [Compute kernel]
   size_t m = I.hnf_basis_.rows();
   size_t n = I.hnf_basis_.columns();
   size_t n1 = J.hnf_basis_.columns();
   VeryLong lcm = I.denominator_ * J.denominator_ / gcd(I.denominator_, J.denominator_);
   Matrix<VeryLong> M1(m, n + n1);
   for (size_t i = 0; i < m; i++)
   {
      for (size_t j = 0; j < n; j++)
      {
         M1(i,j) = I.hnf_basis_(i,j) * (lcm / I.denominator_);
      }
      for (size_t k = 0; k < n1; k++)
      {
         M1(i, n + k) = J.hnf_basis_(i,k) * (lcm / J.denominator_);
      }
   }

   Matrix<VeryLong> N = kernel_over_Z_using_LLL(M1);
   Matrix<VeryLong> N2(n, N.columns());
   for (size_t i = 0; i < n; i++)
   {
      for (size_t j = 0; j < N.columns(); j++)
      {
         N2(i,j) = N(i,j);
      }
   }

   Matrix<VeryLong> M2 = I.hnf_basis_ * N2;

   // step 2. [Compute Intersection]
   Ideal K;
   //K.hnf_basis_ = HNF(M2);
   K.hnf_basis_ = HNF1(M2);
   K.denominator_ = lcm;
   return K;
}

bool Ideal::isIntegral() const
{
   const NumberField& nf = AlgebraicNumber::nf();
   int n = hnf_basis_.rows();

   // H2 gives basis in terms of integral basis
   Matrix<Quotient<VeryLong> > H2(nf.winv());
   H2 *= hnf_basis_;
   H2 /= denominator_;
   const VeryLong one(1L);
   for (int i = 0; i < n; i++)
   {
      for (int j = 0; j < n; j++)
      {
         if (H2(i,j).denominator() != one)
         {
            return false;
         }
      }
   }
   return true;
}

Matrix<VeryLong> Ideal::reducedBasisOmega() const
{
   const NumberField& nf = AlgebraicNumber::nf();
   int n = hnf_basis_.rows();
   // H2 gives basis in terms of integral basis
   Matrix<Quotient<VeryLong> > H2(nf.winv());
   H2 *= hnf_basis_;

   Matrix<VeryLong> rb(n, n);
   const VeryLong one(1L);
   for (int i = 0; i < n; i++)
   {
      for (int j = 0; j < n; j++)
      {
         if (H2(i,j).numerator() % denominator_ != 0L)
         {
             throw std::string("reducedBasisOmega can only be calculated for integral ideals");
         }
         rb(i,j) = H2(i,j).numerator() / denominator_;
      }
   }
   LLL_reduce_3_on_columns(rb);

   return rb;
}

Ideal::~Ideal()
{
}

Quotient<VeryLong> Ideal::norm() const
{
   VeryLong d = AlgebraicNumber::index();
   int degree = hnf_basis_.rows();
   int f = degree * (degree - 1);
   f /= 2;
//   cout << "Ideal::norm() : f = " << f << endl;
   VeryLong c_d = AlgebraicNumber::c_d();
   VeryLong e = pow<VeryLong>(c_d, f);
//   cout << "Ideal::norm() : e = " << e << endl;

   for (size_t i = 0; i < hnf_basis_.rows(); i++)
   {
      d *= hnf_basis_(i,i);
      e *= denominator_;
   }
   Quotient<VeryLong> n(d, e);
   return n;
}

std::ostream& operator<<(std::ostream& os, const Ideal& I)
{
   os << "Ideal I : denominator = " << I.denominator_ << ", HNF basis = " << std::endl << I.hnf_basis_;

   return os;
}

// Given a fractional ideal I, return lcm s.t. J = I * lcm is integral.
// Also return matrix AA of J relative to integral basis
void Ideal::integralPart(const Ideal& I, VeryLong& lcm, Matrix<VeryLong>& AA)
{
   const NumberField& nf = AlgebraicNumber::nf();
   int degree = AlgebraicNumber::degree();
   // (N, d) is HNF of the maximal order Z_k
   VeryLong d1 = I.denominator();
   Matrix<Quotient<VeryLong> > Mq(degree, degree);

   Matrix<VeryLong> hnf_basis = I.hnf_basis();
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree; j++)
      {
         Mq(i,j) = Quotient<VeryLong>(hnf_basis(i,j), d1);
      }
   }

   Matrix<Quotient<VeryLong> > Aq = nf.winv() * Mq;
   lcm = 1L;
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree; j++)
      {
         lcm = lcm * Aq(i,j).denominator() / gcd(lcm, Aq(i,j).denominator());
      }
   }
   Ideal J(I);
   J *= lcm;
   d1 = J.denominator();
   hnf_basis = J.hnf_basis();
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree; j++)
      {
         Mq(i,j) = Quotient<VeryLong>(hnf_basis(i,j), d1);
      }
   }
   Aq = nf.winv() * Mq;

   AA.set_size(degree, degree);
   for (int i = 0; i < degree; i++)
   {
      for (int j = 0; j < degree; j++)
      {
         AA(i,j) = Aq(i,j).numerator();
      }
   }
}

Ideal& operator*=(Ideal& I, const std::vector<PrimeIdealRep*>& pirs)
{
   // ??? NOT YET IMPLEMENTED ???
   return I;
}

Ideal& operator*=(Ideal& I, const PrimeIdealRep& pir)
{
   if (pir.isSpecial())
   {
      return operator*=(I, *pir.getPrimeIdeal());
   }
   // More efficient multiplication of an ideal by a prime ideal, using
   // the 2-element representation of the prime ideal
   int d = AlgebraicNumber::degree();
   Matrix<VeryLong> basis(d, 2*d);
   Matrix<Quotient<VeryLong> > qbasis(d, 2*d);

   int k = 0;
   VeryLong lcm(1L);

   const Matrix<VeryLong>& I_basis = I.hnf_basis();
   const VeryLong& I_denominator = I.denominator();

   //VeryLong a_1 = -AlgebraicNumber::c_d();
   //VeryLong a_0 = pir.r() * a_1;

   for (int i = 0; i < d; i++)
   {
      //AlgebraicNumber v(I.hnf_basis(), I.denominator(), i);
      //AlgebraicNumber u(v);
      //v *= pir.p();
      for (int l = 0; l < d; l++)
      {
         Quotient<VeryLong> qv(I_basis(l,i) * pir.p(), I_denominator);
         qbasis(l,k) = qv;
         lcm = lcm * qv.denominator() / gcd(lcm, qv.denominator());
         //qbasis(l,k) = v.coefficient(l);
         //lcm = lcm * v.coefficient(l).denominator() / gcd(lcm, v.coefficient(l).denominator());
      }
      k++;
      AlgebraicNumber u(I.hnf_basis(), I.denominator(), i);
      u.multiply_by_alpha_minus_r(pir.r());
      //u.multiply(a_0, a_1);
      //u.multiply(-pir.r()*AlgebraicNumber::c_d(), -AlgebraicNumber::c_d());
      //u *= (*pir.getAlpha());
      for (int l = 0; l < d; l++)
      {
         qbasis(l,k) = u.coefficient(l);
         lcm = lcm * u.coefficient(l).denominator() / gcd(lcm, u.coefficient(l).denominator());
      }
      k++;
   }

   for (int i = 0; i < d; i++)
   {
      for (int j = 0; j < 2 * d; j++)
      {
         basis(i,j) = qbasis(i,j).numerator() * (lcm / qbasis(i,j).denominator());
      }
   }
   //std::cerr << basis << std::endl;
   //std::cerr << "----------------------------------------------" << std::endl;
   //I = Ideal(HNF(basis), lcm);
   I = Ideal(HNF1(basis), lcm);

   return I;
}

// Ideal_mod_pO class
VeryLong Ideal_mod_pO::p_;

Ideal_mod_pO::Ideal_mod_pO(const Matrix<VeryLongModular>& F_p_basis) : F_p_basis_(F_p_basis)
{
}

Ideal_mod_pO::Ideal_mod_pO(const Ideal_mod_pO& IpO) : F_p_basis_(IpO.F_p_basis_)
{
}

Ideal_mod_pO::~Ideal_mod_pO()
{
}

bool Ideal_mod_pO::operator==(const Ideal_mod_pO& rhs)
{
    return F_p_basis_ == rhs.F_p_basis_;
}

Ideal_mod_pO& Ideal_mod_pO::operator=(const Ideal_mod_pO& IpO)
{
   if (this == &IpO) return *this;
   F_p_basis_ = IpO.F_p_basis_;
   return *this;
}

// Algorithm 6.2.5 (Ideal Multiplication Modulo pO)
Ideal_mod_pO operator*(const Ideal_mod_pO& IpO1,
                       const Ideal_mod_pO& IpO2)
{
//   std::cerr << "operator*(Ideal_mod_pO)" << std::endl;
//   std::cerr << IpO1.p_ << std::endl;
//   std::cerr << IpO1.basis() << std::endl;
//   std::cerr << IpO2.basis() << std::endl;
   int d = AlgebraicNumber::nf().degree();
   int r = IpO1.F_p_basis_.columns();
   int m = IpO2.F_p_basis_.columns();
//   if (r == 0) return IpO1;
//   if (m == 0) return IpO2;
   const Matrix<VeryLongModular>& A = IpO1.F_p_basis_;
   const Matrix<VeryLongModular>& B = IpO2.F_p_basis_;
//   cout << "A = " << endl << A;
//   cout << "B = " << endl << B;
   // Step 1. [Compute matrix]
   Matrix<VeryLongModular> M(d, r*m);
   int ij = 0;
   for (int i = 0; i < r; i++)
   {
      for (int j = 0; j < m; j++)
      {
         for (int row = 0; row < d; row++)
         {
            Quotient<VeryLong> tmp(0L);
            int kl = 0;
            for (int k = 0; k < d; k++)
            {
               for (int l = 0; l < d; l++)
               {
                  tmp += A(k,i).get_very_long() * B(l,j).get_very_long() * AlgebraicNumber_in_O_pO::W_mult()(row, kl);
                  kl++;
               }
            }
//            cout << "(i,j) = (" << i << "," << j << "), row = " << row << ", tmp = " << tmp << endl;
            M(row, ij) = VeryLongModular(tmp.numerator()) / VeryLongModular(tmp.denominator());
         }
         ij++;
      }
   }

//   cout << "M = " << endl << M;

   // Step 2. [Compute Image]
   Matrix<VeryLongModular> M1 = image(M);

//   cout << "Image of M = " << endl << M1;

//   std::cerr << "result = " << M1 << std::endl;
   return Ideal_mod_pO(M1);
}

Ideal Ideal_mod_pO::makeIdeal()
{
   const std::vector<AlgebraicNumber>& omega = AlgebraicNumber::integralBasis();
   int degree = omega.size();
   std::vector<AlgebraicNumber> beta;
   beta.resize(degree);
   const Matrix<VeryLongModular>& Beta = F_p_basis_;
   int l = F_p_basis_.columns();
   // Beta gives coefficients of beta[i] in terms of the omega[i]
   // Calculate beta[i] explicitly
   for (int i = 0; i < l; i++)
   {
      beta[i] = AlgebraicNumber(VeryLong(0L));
      for (int j = 0; j < degree; j++)
      {
         beta[i] = beta[i] + Beta(j,i).get_very_long() * omega[j];
      }
      //cout << "beta[" << i << "] = " << beta[i] << endl;
   }
   for (int i = l; i < degree; i++)
   {
      beta[i] = VeryLong(p_) * omega[i];
      //cout << "beta[" << i << "] = " << beta[i] << endl;
   }
   Ideal I(beta);
//   cout << "makeIdeal: I = " << endl << I;
//   cout << "makeIdeal: N(I) = " << endl << I.norm() << endl;
   return I;
}

// Algorithm 6.2.7 (Ideal Division Modulo pO)
Ideal_mod_pO operator/(const Ideal_mod_pO& IpO1,
                       const Ideal_mod_pO& IpO2)
{
//   std::cerr << "operator/(Ideal_mod_pO)" << std::endl;
//   std::cerr << IpO1.p_ << std::endl;
//   std::cerr << IpO1.basis() << std::endl;
//   std::cerr << IpO2.basis() << std::endl;
//   cout << "Ideal_mod_pO operator/" << endl;
   int d = AlgebraicNumber::nf().degree();
   int r = IpO1.F_p_basis_.columns();
   int m = IpO2.F_p_basis_.columns();
   const Matrix<VeryLongModular>& A = IpO1.F_p_basis_;
   const Matrix<VeryLongModular>& B = IpO2.F_p_basis_;
   AlgebraicNumber::integralBasis();

   // Step 1. [Find basis of J/I]
//   cout << "A = " << endl << A;
//   cout << "B = " << endl << B;
   Matrix<VeryLongModular> C = supplement_subspace(A, B);
//   cout << "C = " << endl << C;

   // Step 2. [Setup Ideal division]

   Matrix<VeryLongModular> D(d, m);
   for (int j = 0; j < m - r; j++)
   {
      for (int i = 0; i < d; i++)
      {
         D(i,j) = C(i,j);
      }
   }
   for (int j = m - r; j < m; j++)
   {
      for (int i = 0; i < d; i++)
      {
         D(i,j) = A(i, j - m + r);
      }
   }

//   cout << "D = " << endl << D;

   Matrix<VeryLongModular> V(d, d*(m - r));
   int ik = 0;
   for (int i = 0; i < m - r; i++)
   {
      for (int k = 0; k < d; k++)
      {
         for (int j = 0; j < d; j++)
         {
            Quotient<VeryLong> V_kij(0L);
            for (int l = 0; l < d; l++)
            {
               V_kij += C(l,i).get_very_long() * AlgebraicNumber_in_O_pO::W_mult()(j, k*d + l);
            }
            V(j,ik) = VeryLongModular(V_kij.numerator()) / VeryLongModular(V_kij.denominator()) ;
         }
         ik++;
      }
   }

//   cout << "V = " << endl << V;
   Matrix<VeryLongModular> Y = inverse_image_matrix(D, V);
//   cout << "Y = " << endl << Y;
//   cout << "Check: DY = " << endl << D * Y;

   Matrix<VeryLongModular> M((m-r)*(m-r), d);

   int ij = 0;
   for (int i = 0; i < m - r; i++)
   {
      for (int j = 0; j < m - r; j++)
      {
         for (int k = 0; k < d; k++)
         {
            M(ij, k) = Y(j, i*d + k);
         }
         ij++;
      }
   }
//   cout << "M = " << endl << M;

   // Step 3. [Compute IJ^(-1)/pO]
//   cout << "About to call kernel(M)" << endl;
   Matrix<VeryLongModular> M1 = kernel(M);
//   cout << "M1 = " << endl << M1;

//   std::cerr << "result = " << M1 << std::endl;
   return Ideal_mod_pO(M1);
}


void Ideal_mod_pO::set_basis(const VeryLong& p)
{
   p_ = p;
   VeryLongModular::set_default_modulus(p_);
}

Matrix<VeryLongModular> SeparableAlgebraElement::A_(1,1);

SeparableAlgebraElement& SeparableAlgebraElement::operator=(const SeparableAlgebraElement& sa)
{
   if (this != &sa) F_p_basis_ = sa.F_p_basis_;
   return *this;
}

SeparableAlgebraElement operator*(const SeparableAlgebraElement& sa1,
                                  const SeparableAlgebraElement& sa2)
{
   // std::cout << "SeparableAlgebraElement operator*" << std::endl;
   // std::cout << "A_ = " << std::endl << SeparableAlgebraElement::A_;
   // std::cout << "sa1 = " << sa1 << std::endl;
   // std::cout << "sa2 = " << sa2 << std::endl;
   // multiply using A_
   int f = SeparableAlgebraElement::A_.rows();
   std::vector<VeryLongModular> x;
   x.resize(f);
   for (int k = 0; k < f; k++)
   {
      VeryLongModular xx(0L);
      int ij = 0;
      for (int i = 0; i < f; i++)
      {
         for (int j = 0; j < f; j++)
         {
//            cout << "(i, j, ij) = (" << i << ", " << j << ", " << ij << ")" << endl;
//            cout << "sa1.F_p_basis_[i] * sa2.F_p_basis_[j] * SeparableAlgebraElement::A_(k,ij) = " << sa1.F_p_basis_[i] * sa2.F_p_basis_[j] * SeparableAlgebraElement::A_(k,ij) << endl;
            xx += sa1.F_p_basis_[i] * sa2.F_p_basis_[j] * SeparableAlgebraElement::A_(k,ij);
//            cout << "xx = " << xx << endl;
            ij++;
         }
      }
      x[k] = xx;
   }
   return SeparableAlgebraElement(x);
}

SeparableAlgebraElement& SeparableAlgebraElement::operator*=(const SeparableAlgebraElement& sa)
{
   *this = *this * sa;
   return *this;
}

SeparableAlgebraElement operator-(const SeparableAlgebraElement& sa1,
                                  const SeparableAlgebraElement& sa2)
{
   int f = SeparableAlgebraElement::A_.rows();
   std::vector<VeryLongModular> x;
   x.resize(f);
   for (int i = 0; i < f; i++)
   {
      x[i] = sa1.F_p_basis_[i] - sa2.F_p_basis_[i];
   }
   return SeparableAlgebraElement(x);
}

SeparableAlgebraElement operator+(const SeparableAlgebraElement& sa1,
                                  const SeparableAlgebraElement& sa2)
{
   int f = SeparableAlgebraElement::A_.rows();
   std::vector<VeryLongModular> x;
   x.resize(f);
   for (int i = 0; i < f; i++)
   {
      x[i] = sa1.F_p_basis_[i] + sa2.F_p_basis_[i];
   }
   return SeparableAlgebraElement(x);
}

SeparableAlgebraElement operator+(const SeparableAlgebraElement& sa1,
                                  const VeryLongModular& vlm)
{
   int f = SeparableAlgebraElement::A_.rows();
   std::vector<VeryLongModular> x;
   x.resize(f);
   x[0] = sa1.F_p_basis_[0] + vlm;
   for (int i = 1; i < f; i++)
   {
      x[i] = sa1.F_p_basis_[i];
   }
   return SeparableAlgebraElement(x);
}

std::ostream& operator<<(std::ostream& os, const PrimeIdealRep& PIR)
{
   if (PIR.special_)
   {
      os << "Special Prime Ideal(" << PIR.pi_->p() << "," << PIR.pi_->ramificationIndex() << "," << PIR.pi_->residualIndex() << "," << PIR.pi_->alpha() << ")";
   }
   else
   {
      os << "Prime Ideal(" << PIR.p_ << "," << PIR.r_ << ")";
   }
   //os << std::endl;

   return os;
}


