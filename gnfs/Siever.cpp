#include "Siever.h"
#include "LongModular.h"
#include "convert.h"
#include "timings.h"

// comparison operator for pairs (a,b) generated by sieve()
int operator< (const std::pair<long int, long int>& p1, const std::pair<long int, long int>& p2)
{
    // order by a and then by b within a:
    if (p1.first < p2.first) return 1;
    if (p1.first > p2.first) return 0;
    if (p1.second < p2.second) return 1;
    return 0;
}

const int LOGQ_BASE = 10;
// calculate log of x to base q
double logq(double x, int q)
{
    return log10(x) / log10((double)q);
}

Siever::Siever(const std::string& config_file) : relfile_(0), alg_factor_base_(0), rat_factor_base_(0), sieve_array_size_(0), sieve_array_(0)
{
    SieveConfig config(config_file.c_str());
    config.display();
    f1_ = config.f1();
    f1d_ = Polynomial<VeryLong>::convert_to_double<double>(f1_);
    f2_ = config.f2();
    f2d_ = Polynomial<VeryLong>::convert_to_double<double>(f2_);
    B1_ = config.B1();
    L1_ = config.L1();
    LP1_ = config.LP1();
    B2_ = config.B2();
    L2_ = config.L2();
    LP2_ = config.LP2();
    L_LP_1_ = L1_;
    for (int i = 0; i < LP1_ - 1; i++) L_LP_1_ *= L1_;
    L_LP_2_ = L2_;
    for (int i = 0; i < LP2_ - 1; i++) L_LP_2_ *= L2_;
    relation_file_ = config.RELATION_FILE();
    SIEVE_BOUND_ADJUSTMENT1_ = config.SIEVE_BOUND_ADJUSTMENT1();
    SIEVE_BOUND_ADJUSTMENT2_ = config.SIEVE_BOUND_ADJUSTMENT2();
    SMALL_PRIME_BOUND_ = config.SMALL_PRIME_BOUND1();
    RESIEVE_ = config.RESIEVE();

    // generate factor base for f, i.e. pairs (p,r) with p <= B, f(r) = 0 mod p
    // should probably be done as a separate step and saved to a file
    std::string tmp = config.SIEVE_ID() + ".fb.dat";
    const char* alg_base_file = tmp.c_str();
    std::string tmp1 = config.SIEVE_ID() + ".rb.dat";
    const char* rat_base_file = tmp1.c_str();
    try
    {
        alg_factor_base_ = new FactorBase(alg_base_file);
    }
    catch (...)
    {
        delete alg_factor_base_;
        alg_factor_base_ = new FactorBase(f1_, B1_, alg_base_file);
    }

    try
    {
        rat_factor_base_ = new FactorBase(rat_base_file);
    }
    catch (...)
    {
        delete rat_factor_base_;
        rat_factor_base_ = new FactorBase(f2_, B2_, rat_base_file);
    }
}

Siever::~Siever()
{
    delete alg_factor_base_;
    delete rat_factor_base_;
}

int Siever::find_cutoff(long int min_A, long int a1, long int a2, double log_mid_value, SIEVE_TYPE* sa)
{
    return (int)log_mid_value;
}

#if 0
int Siever::check_interval(const Polynomial<double>& f, long int L, long int LP,
                           long int a1, long int a2, long int b,
                           long int min_A, SIEVE_TYPE projective_bump, bool first_pass, FactorBase* factor_base)
{
    int potential = 0;
    int sign = 0;
    double L1d = L;
    double L1d2 = L1d;
    for (int i = 0; i < LP - 1; i++) L1d2 *= L1d;
    double log_L1d2 = logq(L1d2, LOGQ_BASE);

    VeryLong value1 = f.evaluate_homogeneous((double)a1, (double)b);
    VeryLong value2 = f.evaluate_homogeneous((double)a2, (double)b);
    //cout << "value1 = " << value1.get_double() << ", value2 = " << value2.get_double() << std::endl;


    VeryLong diff_value_vl = value2 - value1;
    double diff_value = diff_value_vl.get_double();
    if (diff_value < 0.0)
    {
        diff_value = -diff_value;
        sign = 1;
    }

    //double LOG_DIFF_LIMIT = logq(fabs(value1.get_double()), LOGQ_BASE) - 0.5;
    //if (a2 - a1 == 1L || diff_value < 1e-15 || logq(diff_value, LOGQ_BASE) < LOG_DIFF_LIMIT)
    {
        double log_mid_value = 0.0;
        if (sign) log_mid_value = logq(fabs(value1.get_double() - diff_value), LOGQ_BASE) - log_L1d2;
        else log_mid_value = logq(fabs(value1.get_double() + diff_value), LOGQ_BASE) - log_L1d2;

        int cutoff = find_cutoff(min_A, a1, a2, log_mid_value, sieve_array_);
        cutoff -= projective_bump;
        int adjustment = SIEVE_BOUND_ADJUSTMENT1_;
        if (!first_pass) adjustment = SIEVE_BOUND_ADJUSTMENT2_;
        long int a = a1;
        SIEVE_TYPE* sieve_ptr = &sieve_array_[a - min_A];
        //int count = 0;
        int chunk = 0;
        for (chunk = 0; chunk < cache_chunks_ && a >= first_a_[chunk]; chunk++)
        {}
        chunk--;
        long int change_chunk_at = a2;
        if (chunk < cache_chunks_) change_chunk_at = first_a_[chunk + 1];

        while (a < a2)
        {
            //if ((int)sieve_array_[a - min_A] > (cutoff - adjustment) && gcd(a, b) == 1L)
            //if ((int)(*sieve_ptr) > (cutoff - adjustment) && gcd(a, b) == 1L)
            if ((int)(*sieve_ptr) > (cutoff - adjustment))
            {
                *sieve_ptr = 0;
                potential++;
                dont_skip_[chunk] = 1;
            }
            else
            {
                *sieve_ptr = -128;
            }
            a++;
            sieve_ptr++;
            if (a >= change_chunk_at)
            {
                chunk++;
                if (chunk < cache_chunks_) change_chunk_at = first_a_[chunk + 1];
                else change_chunk_at = a2;
                dont_skip_[chunk] = 0;
            }
        }
    }
    return potential;
}
#endif
#if 1
int Siever::check_interval(const Polynomial<double>& f, long int L, long int LP,
                           long int a1, long int a2, long int b,
                           long int min_A, SIEVE_TYPE projective_bump, bool first_pass, FactorBase* factor_base)
{
    // find an interval, [a1,a2] on which F[a,b]/L1^2 doesn't change too much,
    // and then check value in sieve array sieve_array_ against the mid value in the range.
    // this allows potentially smooth pairs (a,b) to be found without having to
    // evaluate F[a,b] at every point.

    // call recursively until difference between f(a1, b)/L1^2 and f(a2, b)/L1^2 is small enough
    // and then check for potentially smooth values.
    // What is a small enough difference? I put my finger in the air and picked:

    int potential = 0;
    int sign = 0;
    double L1d = L;
    double L1d2 = L1d;
    for (int i = 0; i < LP - 1; i++) L1d2 *= L1d;
    double log_L1d2 = logq(L1d2, LOGQ_BASE);

    VeryLong value1 = f.evaluate_homogeneous((double)a1, (double)b);
    VeryLong value2 = f.evaluate_homogeneous((double)a2, (double)b);
    //cout << "value1 = " << value1.get_double() << ", value2 = " << value2.get_double() << std::endl;


    VeryLong diff_value_vl = value2 - value1;
    double diff_value = diff_value_vl.get_double();
    if (diff_value < 0.0)
    {
        diff_value = -diff_value;
        sign = 1;
    }

    //cout << "diff_value = " << diff_value << ", sign = " << sign << std::endl;
    //cout << "log(diff_value) = " << logq(diff_value, LOGQ_BASE) << std::endl;
    double LOG_DIFF_LIMIT = logq(fabs(value1.get_double()), LOGQ_BASE) - 0.5;
    //cout << "LOG_DIFF_LIMIT = " << LOG_DIFF_LIMIT << std::endl;
    if (a2 - a1 == 1L || diff_value < 1e-15 || logq(diff_value, LOGQ_BASE) < LOG_DIFF_LIMIT)
    {
        //cout << "LOG_DIFF_LIMIT = " << LOG_DIFF_LIMIT << std::endl;
        //cout << "log(diff_value) = " << logq(diff_value, LOGQ_BASE) << std::endl;
        double log_mid_value = 0.0;
        if (sign) log_mid_value = logq(fabs(value1.get_double() - diff_value), LOGQ_BASE) - log_L1d2;
        else log_mid_value = logq(fabs(value1.get_double() + diff_value), LOGQ_BASE) - log_L1d2;
        //cout << "a1 = " << a1 << ", a2 = " << a2 << std::endl;
        //cout << "log_mid_value = " << log_mid_value << std::endl;

        int cutoff = find_cutoff(min_A, a1, a2, log_mid_value, sieve_array_);
        cutoff -= projective_bump;
        int adjustment = SIEVE_BOUND_ADJUSTMENT1_;
        if (!first_pass) adjustment = SIEVE_BOUND_ADJUSTMENT2_;
        long int a = a1;
        SIEVE_TYPE* sieve_ptr = &sieve_array_[a - min_A];
        //int count = 0;
        int chunk = 0;
        for (chunk = 0; chunk < cache_chunks_ && a >= first_a_[chunk]; chunk++)
        {}
        chunk--;
        long int change_chunk_at = a2;
        if (chunk < cache_chunks_) change_chunk_at = first_a_[chunk + 1];

        while (a < a2)
        {
            //if ((int)sieve_array_[a - min_A] > (cutoff - adjustment) && gcd(a, b) == 1L)
            if ((int)(*sieve_ptr) > (cutoff - adjustment) && gcd(a, b) == 1L)
            {
                if (RESIEVE_ && SMALL_PRIME_BOUND_ > 0)
                {
                    //std::cout << "a = " << a << ", cutoff = " << cutoff << ", c-a = " << cutoff - adjustment << ", sieve_array_[a] = " << (int)sieve_array_[a - min_A] << std::endl;
                    //count++;
                    long int p = 0;
                    long int r = 0;
                    long int br = 0;
                    long int amodp = 0;
                    SIEVE_TYPE logp = 0;
                    auto enditer = factor_base->end();
                    for (auto iter = factor_base->begin();
                            iter != enditer && p < SMALL_PRIME_BOUND_;
                            ++iter)
                    {
                        p = iter->get_p();
                        logp = iter->get_logp();
                        amodp = a % p;
                        if (amodp < 0) amodp += p;
                        if (b % p)
                        {
                            for (auto root_info_iter = factor_base->begin(iter);
                                    root_info_iter != factor_base->end(iter);
                                    ++root_info_iter)
                            {
                                r = *root_info_iter;
                                if (r != p)
                                {
                                    br = b;
                                    br *= r;
                                    br %= p;
                                    // check if a = br mod p
                                    if (amodp == br)
                                    {
                                        //std::cout << "Adding logp = " << (int)logp << ", for p = " << p << ", r = " << r << std::endl;
                                        //sieve_array_[a - min_A] += logp;
                                        *sieve_ptr += logp;
                                    }
                                }
                            }
                        }
                    }
                    //std::cout << "a = " << a << ", cutoff = " << cutoff << ", sieve_array_[a] = " << (int)sieve_array_[a - min_A] << std::endl;
                    //if ((int)sieve_array_[a - min_A] > cutoff)
                    if ((int)(*sieve_ptr) >= cutoff)
                    {
                        //sieve_array_[a - min_A] = 0;
                        *sieve_ptr = 0;
                        potential++;
                        dont_skip_[chunk] = 1;
                    }
                    else
                    {
                        //sieve_array_[a - min_A] = -128;
                        *sieve_ptr = -128;
                    }
                }
                else
                {
                    //sieve_array_[a - min_A] = 0;
                    *sieve_ptr = 0;
                    potential++;
                    dont_skip_[chunk] = 1;
                }
            }
            else
            {
                //sieve_array_[a - min_A] = -128;
                *sieve_ptr = -128;
            }
            a++;
            sieve_ptr++;
            if (a >= change_chunk_at)
            {
                chunk++;
                if (chunk < cache_chunks_) change_chunk_at = first_a_[chunk + 1];
                else change_chunk_at = a2;
                dont_skip_[chunk] = 0;
            }
        }
//      std::cout << "resieved count = " << count << std::endl;
    }
    else
    {
        potential = check_interval(f, L, LP, a1, (a1 + a2)/2, b, min_A, projective_bump, first_pass, factor_base);
        potential += check_interval(f, L, LP, (a1 + a2)/2, a2, b, min_A, projective_bump, first_pass, factor_base);
    }
    return potential;
}
#else
int Siever::check_interval(const Polynomial<double>& f, long int L, long int LP,
                           long int a1, long int a2, long int b,
                           long int min_A, SIEVE_TYPE projective_bump, bool first_pass, FactorBase* factor_base)
{
    int potential = 0;
    double L1d = L;
    double L1d2 = L1d;
    for (int i = 0; i < LP - 1; i++) L1d2 *= L1d;
    double log_L1d2 = logq(L1d2, LOGQ_BASE);

    const long int check_frequency = 4000L;
    double value1;
    double log_mid_value = 0L;
    int cutoff = 0L;
    long int loop_count = 0L;
    int adjustment = SIEVE_BOUND_ADJUSTMENT1_;
    if (!first_pass) adjustment = SIEVE_BOUND_ADJUSTMENT2_;
    long int a = a1;
    SIEVE_TYPE* sieve_ptr = &sieve_array_[a - min_A];
    //int count = 0;
    int chunk = 0;
    for (chunk = 0; chunk < cache_chunks_ && a >= first_a_[chunk]; chunk++)
    {}
    chunk--;
    long int change_chunk_at = a2;
    if (chunk < cache_chunks_) change_chunk_at = first_a_[chunk + 1];

    while (a < a2)
    {
        if (loop_count % check_frequency == 0L)
        {
            value1 = f.evaluate_homogeneous((double)a, (double)b);
            log_mid_value = logq(fabs(value1), LOGQ_BASE) - log_L1d2;
            cutoff = static_cast<int>(log_mid_value);
            cutoff -= projective_bump;
            if (first_pass) cutoff -= 10;
        }
        if ((int)(*sieve_ptr) > (cutoff - adjustment) && gcd(a, b) == 1L)
        {
            if (SMALL_PRIME_BOUND_ > 0)
            {
                //std::cout << "a = " << a << ", cutoff = " << cutoff << ", c-a = " << cutoff - adjustment << ", sieve_array_[a] = " << (int)sieve_array_[a - min_A] << std::endl;
                //count++;
                long int p = 0;
                long int r = 0;
                long int br = 0;
                long int amodp = 0;
                SIEVE_TYPE logp = 0;
                auto enditer = factor_base->end();
                for (auto iter = factor_base->begin();
                        iter != enditer && p < SMALL_PRIME_BOUND_;
                        ++iter)
                {
                    p = iter->get_p();
                    logp = iter->get_logp();
                    amodp = a % p;
                    if (amodp < 0) amodp += p;
                    if (b % p)
                    {
                        for (auto root_iter = factor_base->begin(iter);
                                root_iter != factor_base->end(iter);
                                ++root_iter)
                        {
                            r = *root_iter;
                            if (r != p)
                            {
                                br = b;
                                br *= r;
                                br %= p;
                                // check if a = br mod p
                                if (amodp == br)
                                {
                                    //std::cout << "Adding logp = " << (int)logp << ", for p = " << p << ", r = " << r << std::endl;
                                    //sieve_array_[a - min_A] += logp;
                                    *sieve_ptr += logp;
                                }
                            }
                        }
                    }
                }
                //std::cout << "a = " << a << ", cutoff = " << cutoff << ", sieve_array_[a] = " << (int)sieve_array_[a - min_A] << std::endl;
                //if ((int)sieve_array_[a - min_A] > cutoff)
                if ((int)(*sieve_ptr) >= cutoff)
                {
                    //sieve_array_[a - min_A] = 0;
                    *sieve_ptr = 0;
                    potential++;
                    dont_skip_[chunk] = 1;
                }
                else
                {
                    //sieve_array_[a - min_A] = -128;
                    *sieve_ptr = -128;
                }
            }
            else
            {
                //sieve_array_[a - min_A] = 0;
                *sieve_ptr = 0;
                potential++;
                dont_skip_[chunk] = 1;
            }
        }
        else
        {
            //sieve_array_[a - min_A] = -128;
            *sieve_ptr = -128;
        }
        a++;
        sieve_ptr++;
        loop_count++;
        if (a >= change_chunk_at)
        {
            chunk++;
            if (chunk < cache_chunks_) change_chunk_at = first_a_[chunk + 1];
            else change_chunk_at = a2;
            dont_skip_[chunk] = 0;
        }
    }
    return potential;
}
#endif

int Siever::find_cutoff(const Polynomial<VeryLong>& f, long int L, long int LP,
                        long int a1, long int a2, long int b)
{
    int sign = 0;
    double L1d = L;
    double L1d2 = L1d;
    for (int i = 0; i < LP - 1; i++) L1d2 *= L1d;
    double log_L1d2 = logq(L1d2, LOGQ_BASE);
    int cutoff = 0;

    VeryLong value1 = f.evaluate_homogeneous(a1, b);
    VeryLong value2 = f.evaluate_homogeneous(a2, b);

    VeryLong diff_value_vl = value2 - value1;
    double diff_value = diff_value_vl.get_double();
    if (diff_value < 0.0)
    {
        diff_value = -diff_value;
        sign = 1;
    }

    double log_mid_value = 0.0;
    if (sign) log_mid_value = logq(fabs(value1.get_double() - diff_value), LOGQ_BASE) - log_L1d2;
    else log_mid_value = logq(fabs(value1.get_double() + diff_value), LOGQ_BASE) - log_L1d2;

    cutoff = (int)log_mid_value;
    return cutoff;
}

int Siever::check_interval(int cutoff, long int a1, long int a2, long int b,
                           long int min_A, bool first_pass, FactorBase* factor_base)
{
    int potential = 0;

    int adjustment = SIEVE_BOUND_ADJUSTMENT1_;
    if (!first_pass) adjustment = SIEVE_BOUND_ADJUSTMENT2_;
    long int a = a1;
    //int count = 0;

    while (a < a2)
    {
        if ((int)sieve_array_[a - min_A] > (cutoff - adjustment) && gcd(a, b) == 1L)
        {
            if (SMALL_PRIME_BOUND_ > 0)
            {
                //count++;
                long int p = 0;
                long int r = 0;
                long int br = 0;
                long int amodp = 0;
                SIEVE_TYPE logp = 0;
                auto enditer = factor_base->end();
                for (auto iter = factor_base->begin();
                        iter != enditer && p < SMALL_PRIME_BOUND_;
                        ++iter)
                {
                    p = iter->get_p();
                    logp = iter->get_logp();
                    amodp = a % p;
                    if (amodp < 0) amodp += p;
                    if (b % p)
                    {
                        for (auto root_info_iter = factor_base->begin(iter);
                                root_info_iter != factor_base->end(iter);
                                ++root_info_iter)
                        {
                            r = *root_info_iter;
                            if (r != p)
                            {
                                br = b;
                                br *= r;
                                br %= p;
                                // check if a = br mod p
                                if (amodp == br)
                                {
                                    sieve_array_[a - min_A] += logp;
                                }
                            }
                        }
                    }
                }
                if ((int)sieve_array_[a - min_A] > cutoff)
                {
                    sieve_array_[a - min_A] = 0;
                    potential++;
                }
                else sieve_array_[a - min_A] = -128;
            }
            else
            {
                sieve_array_[a - min_A] = 0;
            }
        }
        else
        {
            sieve_array_[a - min_A] = -128;
        }
        a++;
    }
    return potential;
}

void Siever::sieve(const Polynomial<double>& f, const VeryLong& c_d,
                   long int min_A, long int max_A, long int b, bool is_first_b, long int L, long int LP,
                   FactorBase* factor_base, bool first_pass)
{
    std::cout << "Sieving ... f = " << f << std::endl;
    std::cout << "min_A = " << min_A << ", max_A = " << max_A << ", b = " << b << ", L = " << L << std::endl;
    long int a = 0L;
    long int p = 0;
    // Note: 0 corresponds to min_A, so we index into sieve_array_ like this:
    // sieve_array_[a - min_A]

    SIEVE_TYPE projective_bump = 0;
    long int c_d_mod_p = 0L;
    long int b_mod_p = 0L;
    long long int pll = 0L;
    SIEVE_TYPE logp = 0;
    SIEVE_TYPE* sieve_end_ptr = &sieve_array_[max_A - min_A];

    // divide sieve array into chunks that fit into the L1 cache (L1_SIZE)
    //const int L1_BITS = 18; // best time: 18 sec/line
    const int L1_BITS = 19; // best time: 15 sec/line
    const long int L1_SIZE = (1L<<L1_BITS);
    //const long int L1_SIZE = 524288L;
    //const long int L1_SIZE = 500000L;
    chunk_size_ = L1_SIZE;
//   chunk_size_ = 100000;
//   chunk_size_ = sieve_array_size;
    cache_chunks_ = (sieve_array_size_ - 1L) / chunk_size_+ 1L;
    if (first_pass) for (int i = 0; i < 1024; i++) dont_skip_[i] = 1;

    long int r = 0L;
    long long int br = 0L;
    long long int Y = 0L;
    long long int k = 0L;
    long long int bll = b;
    //long long int min_All = min_A;
    long long int first_a;
    long long int last_a;
    SIEVE_TYPE* sieve_ptr = 0;


    first_a = min_A;
    last_a = first_a + chunk_size_;

    FactorBase::a_const_iterator not_small_prime_start = 0;
    int small_prime = 0;
    int chunk = 0;
    {
        if (first_pass)
        {
            dont_skip_[chunk] = 1;
            first_a_[chunk] = first_a;
        }
        // Always do chunk 0 for second poly to make sure not_small_prime_start is set.
        //if (dont_skip_[chunk])
        {
            sieve_end_ptr = &sieve_array_[last_a - min_A];

            FactorBase::a_const_iterator iter = factor_base->begin();
            auto enditer = factor_base->end();
            if (not_small_prime_start) iter = not_small_prime_start;
            for (;
                    iter != enditer;
                    ++iter)
            {
                p = iter->get_p();
                b_mod_p = b % p;
                c_d_mod_p = c_d % p;
                logp = iter->get_logp();
                small_prime = 0;
                if (SMALL_PRIME_BOUND_ > 0L && p < SMALL_PRIME_BOUND_) small_prime = 1;
                if (!not_small_prime_start && !small_prime) not_small_prime_start = iter;
                pll = p;
                SIEVE_TYPE** next_sieve_ptr = 0;
                long int* a_start_iter = 0;
                for (auto root_info_iter = factor_base->begin(iter);
                        root_info_iter != factor_base->end(iter);
                        ++root_info_iter)
                {
                    r = *root_info_iter;
                    // TEMP - Siever needs to be reworked!!!
                    //a_start_iter = &root_info_iter->c_start;
                    // TEMP
                    //next_sieve_ptr = root_info_iter->sieve_ptr;
                    if (!small_prime && r != p && b_mod_p != 0)
                    {
                        // "hit" each a which is = br mod p
                        // Watch out for overflow!
                        // b - 1 = 0 mod p <=> b = 1 mod p
                        if (is_first_b || b_mod_p == 1)
                        {
                            br = bll;
                            br *= (long long int)r;
                            Y = first_a;
                            Y -= br;
                            k = Y;
                            Y %= pll;
                            if (Y < 0) Y += pll;
                            k -= Y;
                            k /= pll;
                            k++;
                            a = pll;
                            a *= k;
                            a += br;
                            *next_sieve_ptr = &sieve_array_[a - min_A];
                            *a_start_iter = a;
                        }
                        else
                        {
                            // calculate first a for next b
                            // if a = br mod p
                            // then a + r = (b + 1)r mod p
                            a = *a_start_iter + r;
                            if (a - p >= min_A) a -= p;
                            if (a - p >= min_A) a -= p;
                            *a_start_iter = a;
                            *next_sieve_ptr = &sieve_array_[a - min_A];
                        }

                        // seive all values of (a,b) now
                        //sieve_ptr = &sieve_array_[a - min_A];
                        sieve_ptr = *next_sieve_ptr;
                        while (sieve_ptr < sieve_end_ptr)
                        {
                            *sieve_ptr += logp;
                            sieve_ptr += p;
                        }
                        *next_sieve_ptr = sieve_ptr;
                    }
                    else
                    {
                        // projective root
                        if (b_mod_p == 0 && c_d_mod_p == 0) projective_bump += logp;
                    }
                }
            }
        } // dont_skip_[chunk]

        first_a += chunk_size_;
        last_a += chunk_size_;
        if (last_a > max_A) last_a = max_A;
    }

    for (int chunk = 1; chunk < cache_chunks_; chunk++)
    {
        if (chunk % 100 == 0) std::cout << "chunk <" << chunk << "/" << cache_chunks_ << ">" << std::endl;
        if (first_pass)
        {
            dont_skip_[chunk] = 1;
            first_a_[chunk] = first_a;
        }
        if (dont_skip_[chunk])
        {
            sieve_end_ptr = &sieve_array_[last_a - min_A];

            auto iter = not_small_prime_start;
            auto enditer = factor_base->end();
            for (;
                    iter != enditer;
                    ++iter)
            {
                p = iter->get_p();
                b_mod_p = b % p;
                logp = iter->get_logp();
                pll = p;
                SIEVE_TYPE** next_sieve_ptr = 0;
                for (auto root_info_iter = factor_base->begin(iter);
                        root_info_iter != factor_base->end(iter);
                        ++root_info_iter)
                {
                    r = *root_info_iter;
                    //next_sieve_ptr = root_info_iter->sieve_ptr;
                    if (r != p && b_mod_p != 0)
                    {
                        if (!dont_skip_[chunk - 1])
                        {
                            // "hit" each a which is = br mod p
                            // Watch out for overflow!
                            br = bll;
                            br *= (long long int)r;
                            Y = first_a;
                            Y -= br;
                            k = Y;
                            Y %= pll;
                            if (Y < 0) Y += pll;
                            k -= Y;
                            k /= pll;
                            k++;
                            a = pll;
                            a *= k;
                            a += br;
                            *next_sieve_ptr = &sieve_array_[a - min_A];
                        }

                        // seive all values of (a,b) now
                        sieve_ptr = *next_sieve_ptr;
                        while (sieve_ptr < sieve_end_ptr)
                        {
                            *sieve_ptr += logp;
                            sieve_ptr += p;
                        }
                        *next_sieve_ptr = sieve_ptr;
                    }
                }
            }
        } // dont_skip_[chunk]

        first_a += chunk_size_;
        last_a += chunk_size_;
        if (last_a > max_A) last_a = max_A;
    }

    std::cout << "Sieved, now checking ..." << std::endl;
#if 0
    VeryLong pb = gcd(c_d, b);
    projective_bump = (SIEVE_TYPE)logq(pb.get_double(), LOGQ_BASE);
#endif
    check_interval(f, L, LP, min_A, (min_A + max_A) / 2, b, min_A, projective_bump, first_pass, factor_base);
    check_interval(f, L, LP, (min_A + max_A) / 2, max_A, b, min_A, projective_bump, first_pass, factor_base);
}

void Siever::checkRelations(const char* relfile)
{
    std::fstream rels(relfile, std::ios::in);
    std::vector<VeryLong> factors1;
    std::vector<VeryLong> factors2;
    std::string str;
    while (getline(rels, str))
    {
        long long int a;
        long long int b;
        char* alg_str;
        char* rat_str;
        Convert::parse_FBGNFS(str, a, b, alg_str, rat_str);
        std::vector<long int> alg_primes;
        std::vector<long int> rat_primes;
        Convert::extract_FBGNFS_primes(alg_str, alg_primes);
        Convert::extract_FBGNFS_primes(rat_str, rat_primes);

        if (checkForRelation(VeryLong(a), VeryLong(b), f2_, B2_, L2_, LP2_, L_LP_2_, factors2, rat_primes) &&
                checkForRelation(VeryLong(a), VeryLong(b), f1_, B1_, L1_, LP1_, L_LP_1_, factors1, alg_primes))
        {
            std::cout << a << " " << b << " :";
            std::sort(factors1.begin(), factors1.end());
            std::sort(factors2.begin(), factors2.end());
            for (size_t i = 0; i < factors1.size(); i++)
            {
                long int p = factors1[i].get_long();
                alg_factor_base_->add_extra(p);
                LongModular::set_default_modulus(p);
                VeryLong c_d = f1_.coefficient(f1_.deg());
                VeryLong p_vl(p);
                const VeryLong zero(0L);
                int done = 0;
                for (auto iter = alg_factor_base_->begin(p);
                        !done && iter != alg_factor_base_->end(p);
                        ++iter)
                {
                    long int r = *iter;
                    if (r == p) done = 1;
                    else
                    {
                        long long int xll = b % p;
                        xll *= r;
                        long int x = xll % p;
                        if (x < 0) x += p;
                        long int y = a % p;
                        if (y < 0) y += p;
                        if (x == y) done = 1;
                    }
                    if (done) std::cout << " " << p << "/" << r;
                }
                if (!done && b % p == 0) std::cout << " " << p << "/" << p;
            }
            std::cout << " :";
            for (size_t i = 0; i < factors2.size(); i++)
            {
                std::cout << " " << factors2[i];
            }
            if (factors2.size() == 0) std::cout << " 1";
            std::cout << " :";
            std::cout << std::endl;
        }
    }

}

int Siever::checkForRelation(const VeryLong& a, const VeryLong& b,
                             const Polynomial<VeryLong>& f,
                             long int B, long int L, long int LP, const VeryLong& L_LP,
                             std::vector<VeryLong>& factors)
{
    VeryLong value = f.evaluate_homogeneous(a, b);
    //std::cerr << "f(a,b) = " << value << std::endl;
    factors.clear();
    VeryLong tmp = value;
    if (tmp < 0L) tmp = -tmp;
    int large_primes = 0;
    const VeryLong one(1L);
    // First of all use trial division
    VeryLong tmp1;
    std::vector<long int> ifactors;
    VeryLong::set_max_prime(B);
    if (B > VeryLong::get_max_prime())
    {
        tmp.factorise_trial_division(&ifactors, &tmp1, B);
    }
    else
    {
        tmp.factorise_trial_division(&ifactors, &tmp1);
    }
    if (tmp1 == one || (tmp1 <= B && tmp1.is_probable_prime()))
    {
        for (size_t i = 0; i < ifactors.size(); i++)
        {
            factors.push_back(VeryLong(ifactors[i]));
        }
        if (tmp1 != one && tmp1 <= B) factors.push_back(tmp1);
        return 1;
    }
    if (tmp1 > B && tmp1 <= L && LP > 0 && tmp1.is_probable_prime())
    {
        for (size_t i = 0; i < ifactors.size(); i++)
        {
            factors.push_back(VeryLong(ifactors[i]));
        }
        if (tmp1 != one && tmp1 <= L) factors.push_back(tmp1);
        return 1;
    }
    // here if tmp1 != 1 and (tmp1 > L or tmp1 is composite)
    if (LP == 0)
    {
        std::cerr << "LP == 0, tmp1 = " << tmp1 << ", B = " << B << ", L = " << L << std::endl;
        return 0;
    }
    if (tmp1 <= L)
    {
        // tmp1 is a composite <= L, so split it
        // By definition, if we are here tmp1 has factors larger than MAX_PRIME
        // in VeryLong.cpp, but less than L
        for (size_t i = 0; i < ifactors.size(); i++)
        {
            factors.push_back(VeryLong(ifactors[i]));
        }
        std::cerr << "1. Calling factorise on " << tmp1 << std::endl;
        tmp1.factorise_no_trial(&factors);
        std::cerr << "1. done" << std::endl;
        return 1;
    }
    // here if tmp1 > L
    // we are allowing LP large primes <= L
    if (tmp1.is_probable_prime())
    {
        std::cerr << tmp1 << " is probable prime > " << L << std::endl;
        return 0;
    }
    // Note that we could have MAX_PRIME < B, in which case tmp1 may still contain some
    // factors > MAX_PRIME and < B
    if (tmp1 / L_LP > B)
    {
        std::cerr << "not smooth : tmp1 = " << tmp1 << ", L_LP = " << L_LP << ", tmp1 / L_LP = " << tmp1 / L_LP << ", B = " << B << std::endl;
        return 0;
    }
    //std::cout << "tmp1 = " << tmp1 << ", L_LP = " << L_LP << ", tmp1 / L_LP = " << tmp1 / L_LP << ", B = " << B << std::endl;
    std::vector<VeryLong> factors1;

    std::cerr << "2. Calling factorise on " << tmp1 << std::endl;
    tmp1.factorise_no_trial(&factors1);
    std::cerr << "2. done" << std::endl;

    for (size_t i = 0; i < factors1.size(); i++)
    {
        if (factors1[i] > L)
        {
            std::cerr << std::endl;
            std::cerr << "not smooth : " << L << " < " << factors1[i] << std::endl;
            //cout << "not smooth : " << L << " < " << factors1[i] << std::endl;
            return 0;
        }
        if (factors1[i] > B && factors1[i] <= L) large_primes++;
    }
    //if (large_primes <= LP)
    {
        std::cerr << "smooth : " << std::endl;
        //cout << "smooth : " << std::endl;
        for (size_t i = 0; i < ifactors.size(); i++)
        {
            factors.push_back(VeryLong(ifactors[i]));
        }
        for (size_t i = 0; i < factors1.size(); i++)
        {
            factors.push_back(factors1[i]);
        }
        return 1;
    }
    std::cerr << "falling through, large_primes = " << large_primes << ", LP = " << LP << std::endl;
    return 0;
}

int Siever::checkForRelation(const VeryLong& a, const VeryLong& b,
                             const Polynomial<VeryLong>& f,
                             long int B, long int L, long int LP, const VeryLong& L_LP,
                             std::vector<VeryLong>& factors, const std::vector<long int>& primes)
{
    VeryLong value = f.evaluate_homogeneous(a, b);
    //std::cerr << "f(a,b) = " << value << std::endl;
    factors.clear();
    VeryLong tmp = value;
    if (tmp < 0L) tmp = -tmp;
    int large_primes = 0;
    const VeryLong one(1L);
    // Zeroth of all remove primes from f(a,b)
    for (size_t i = 0; i < primes.size(); ++i)
    {
        if (tmp % primes[i] == 0L)
        {
            tmp /= primes[i];
            factors.push_back(VeryLong(primes[i]));
        }
    }

    // First of all use trial division
    VeryLong tmp1;
    std::vector<long int> ifactors;
    VeryLong::set_max_prime(B);
    if (B > VeryLong::get_max_prime())
    {
        tmp.factorise_trial_division(&ifactors, &tmp1, B);
    }
    else
    {
        tmp.factorise_trial_division(&ifactors, &tmp1);
    }
    if (tmp1 == one || (tmp1 <= B && tmp1.is_probable_prime()))
    {
        for (size_t i = 0; i < ifactors.size(); i++)
        {
            factors.push_back(VeryLong(ifactors[i]));
        }
        if (tmp1 != one && tmp1 <= B) factors.push_back(tmp1);
        return 1;
    }
    if (tmp1 > B && tmp1 <= L && LP > 0 && tmp1.is_probable_prime())
    {
        for (size_t i = 0; i < ifactors.size(); i++)
        {
            factors.push_back(VeryLong(ifactors[i]));
        }
        if (tmp1 != one && tmp1 <= L) factors.push_back(tmp1);
        return 1;
    }
    // here if tmp1 != 1 and (tmp1 > L or tmp1 is composite)
    if (LP == 0)
    {
        std::cerr << "LP == 0, tmp1 = " << tmp1 << ", B = " << B << ", L = " << L << std::endl;
        return 0;
    }
    if (tmp1 <= L)
    {
        // tmp1 is a composite <= L, so split it
        // By definition, if we are here tmp1 has factors larger than MAX_PRIME
        // in VeryLong.cpp, but less than L
        for (size_t i = 0; i < ifactors.size(); i++)
        {
            factors.push_back(VeryLong(ifactors[i]));
        }
        std::cerr << "1. Calling factorise on " << tmp1 << std::endl;
        tmp1.factorise_no_trial(&factors);
        std::cerr << "1. done" << std::endl;
        return 1;
    }
    // here if tmp1 > L
    // we are allowing LP large primes <= L
    if (tmp1.is_probable_prime())
    {
        std::cerr << tmp1 << " is probable prime > " << L << std::endl;
        return 0;
    }
    // Note that we could have MAX_PRIME < B, in which case tmp1 may still contain some
    // factors > MAX_PRIME and < B
    if (tmp1 / L_LP > B)
    {
        std::cerr << "not smooth : tmp1 = " << tmp1 << ", L_LP = " << L_LP << ", tmp1 / L_LP = " << tmp1 / L_LP << ", B = " << B << std::endl;
        return 0;
    }
    //std::cout << "tmp1 = " << tmp1 << ", L_LP = " << L_LP << ", tmp1 / L_LP = " << tmp1 / L_LP << ", B = " << B << std::endl;
    std::vector<VeryLong> factors1;

    std::cerr << "2. Calling factorise on " << tmp1 << std::endl;
    tmp1.factorise_no_trial(&factors1);
    std::cerr << "2. done" << std::endl;

    for (size_t i = 0; i < factors1.size(); i++)
    {
        if (factors1[i] > L)
        {
            std::cerr << std::endl;
            std::cerr << "not smooth : " << L << " < " << factors1[i] << std::endl;
            //cout << "not smooth : " << L << " < " << factors1[i] << std::endl;
            return 0;
        }
        if (factors1[i] > B && factors1[i] <= L) large_primes++;
    }
    //if (large_primes <= LP)
    {
        std::cerr << "smooth : " << std::endl;
        //cout << "smooth : " << std::endl;
        for (size_t i = 0; i < ifactors.size(); i++)
        {
            factors.push_back(VeryLong(ifactors[i]));
        }
        for (size_t i = 0; i < factors1.size(); i++)
        {
            factors.push_back(factors1[i]);
        }
        return 1;
    }
    std::cerr << "falling through, large_primes = " << large_primes << ", LP = " << LP << std::endl;
    return 0;
}

// Classical sieving for NFS
void Siever::sieve(long int min_A, long int max_A, long int b)
{
    static int firsttime = 1;
    static int first_b;
    if (firsttime)
    {
        firsttime = 0;
        first_b = b;
        timing_file("sieve.tim");
    }
    // Classical sieve for NFS, based on description in
    // "An Implementation of the Number Field Sieve" by Elkenbracht-Huizing

    std::cout << "NFS Classical Sieve:" << std::endl;
    std::cout << "f1 = " << f1_ << std::endl;
    std::cout << "f2 = " << f2_ << std::endl;
    std::cout << "min_A = " << min_A << std::endl;
    std::cout << "max_A = " << max_A << std::endl;
    std::cout << "b = " << b << std::endl;

    // sieve array has one byte for each a value, initialised to zero
    std::cout << "Allocating sieve_array_, max_A - min_A + 1 = " << max_A - min_A + 1 << std::endl;
    long int sieve_array_size = sizeof(SIEVE_TYPE) * (max_A - min_A + 1);
    if (sieve_array_size != sieve_array_size_)
    {
        delete [] sieve_array_;
        sieve_array_ = new SIEVE_TYPE [ max_A - min_A + 1 ];
        sieve_array_size_ = sizeof(SIEVE_TYPE) * (max_A - min_A + 1);
    }
    memset(sieve_array_, (SIEVE_TYPE)0, sieve_array_size_);

    // record potentially smooth pairs (a,b)
    bool first_pass = true;
    VeryLong::set_max_prime(B1_);
    timing_start("sieve 1");
    sieve(f1d_, f1_.coefficient(f1_.deg()), min_A, max_A, b, (first_b == b), L1_, LP1_, alg_factor_base_, first_pass);
    timing_stop();
    int number_of_potentially_alg_smooth = 0;
    for (long int a = min_A; a < max_A; a++)
    {
        if ((int)sieve_array_[a - min_A] == 0)
        {
            number_of_potentially_alg_smooth++;
        }
    }
    std::cout << "Number of potentially alg smooth = " << number_of_potentially_alg_smooth << std::endl;
#if 1
    // now sieve the linear polynomial f2(X) = X - m or f2(X) = a X - b
    first_pass = false;
    VeryLong::set_max_prime(B2_);
    timing_start("sieve 2");
    sieve(f2d_, f2_.coefficient(f2_.deg()), min_A, max_A, b, (first_b == b), L2_, LP2_, rat_factor_base_, first_pass);
    timing_stop();

    int number_of_potentially_smooth = 0;
    for (long int a = min_A; a < max_A; a++)
    {
        if ((int)sieve_array_[a - min_A] == 0)
        {
            number_of_potentially_smooth++;
        }
    }
    std::cout << "Number of potentially smooth = " << number_of_potentially_smooth << std::endl;
#endif
    timing_start("check");
    const VeryLong one(1L);
    std::vector<VeryLong> factors1;
    std::vector<VeryLong> factors2;
    for (long int a = min_A; a < max_A; a++)
    {
        if ((int)sieve_array_[a - min_A] == 0)
        {
            std::cerr << "(" << a << "," << b << ")" << std::endl;
            VeryLong aa(a);
            VeryLong bb(b);
            if (gcd<VeryLong>(a, bb) == one &&
                    checkForRelation(a, bb, f2_, B2_, L2_, LP2_, L_LP_2_, factors2) &&
                    checkForRelation(a, bb, f1_, B1_, L1_, LP1_, L_LP_1_, factors1))
            {
                if (!relfile_)
                {
                    std::cout << "Opening RELATION_FILE (" << relation_file_ << ") ...";
                    relfile_ = new std::fstream(relation_file_.c_str(), std::ios::out|std::ios::app);
                    std::cout << " opened" << std::endl;
                }
                *relfile_ << a << " " << bb << " :";
                for (size_t i = 0; i < factors1.size(); i++)
                {
                    long int p = factors1[i].get_long();
                    if (p >= B1_) alg_factor_base_->add_extra(p);
                    LongModular::set_default_modulus(p);
                    VeryLong c_d = f1_.coefficient(f1_.deg());
                    VeryLong p_vl(p);
                    const VeryLong zero(0L);
                    int done = 0;
                    for (auto iter = alg_factor_base_->begin(p);
                            !done && iter != alg_factor_base_->end(p);
                            ++iter)
                    {
                        long int r = *iter;
                        if (r == p) done = 1;
                        else
                        {
                            long long int xll = bb % p;
                            xll *= r;
                            long int x = xll % p;
                            if (x < 0) x += p;
                            long int y = a % p;
                            if (y < 0) y += p;
                            if (x == y) done = 1;
                        }
                        if (done) *relfile_ << " " << p << "/" << r;
#if 0
                        // check that a = br mod p
                        LongModular x(b % p);
                        x *= LongModular(r);
                        LongModular y((a % p_vl).get_long());
                        if (r == p || x == y)
                        {
                            *relfile_ << " " << p << "/" << r;
                        }
#endif
                    }
                }
                *relfile_ << " :";
                for (size_t i = 0; i < factors2.size(); i++)
                {
                    *relfile_ << " " << factors2[i];
                }
                if (factors2.size() == 0) *relfile_ << " 1";
                *relfile_ << " :";
                *relfile_ << std::endl;
            }
        }
    }
    timing_stop();
    std::cout << "... Done" << std::endl;
//   delete [] sieve_array_;
}
